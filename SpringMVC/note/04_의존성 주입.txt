04_의존성 주입

# 의존성 (Dependency)
	- 한 클래스 내부에서 다른 클래스의 생성자를 가져다 사용하면
		해당 클래스는 다른 클래스에게 의존하는 것이다 (프로젝트도 동일)

# 의존성 주입 (Dependency Injection, DI)
	- 해당 클래스가 의존하는 다른 클래스의 인스턴스를
		해당 클래스 내부에서 직접 생성하는 것이 아니라 외부에서 생성한 후 받아오는 방식
	- 의존의 대상이 되는 클래스의 인스턴스를 생성하는 작업과
		해당 인스턴스에게 의존하는 작업을 별개의 작업으로 두어 코드간의 결합도를 낮출 수 있다
	- 스프링은 원하는 클래스의 인스턴스를 미리 생성하여 스프링 컨텍스트에 보관하고 있다가
		해당 인스턴스가 필요한 곳에 보관 중이던 인스턴스를 알아서 주입해주는 기능을 제공한다
	- 이 때 스프링 컨텍스트에 보관되는 인스턴스들을 Bean이라고 부른다
	- 클래스가 Bean이 되기 위해서는 위에 Bean임을 알리는 어노테이션을 정의해야 한다
	- 이러한 클래스들은 스프링이 자동으로 수거하여 스프링 컨텍스트에 등록한다
	- 이처럼 미리 생성하여 스프링 컨텍스트에 등록되는 Bean들은 자동적으로 싱글톤이 되어
		메모리를 절약하게 되어있다
		
# 스프링의 자동 수거 대상이 되기 위한 어노테이션들
	@Component
		- 컨텍스트 로드(서버 실행)시 스프링이 자동으로 수거해야 하는 모든 대상들을 컴포넌트라고 부른다
		- 용도 구분 없이 해당 클래스가 컴포넌트임을 표시해 놓는 어노테이션
		- 이 어노테이션을 달아놓으면 해당 클래스는 스프링 컨텍스트에 자동으로 수거되어 등록된다
		@Controller
			- 컴포넌트들 중에서 컨트롤러 역할을 하는 컴포넌트들을 등록하기 위해 사용하는 어노테이션
			- 컴포넌트 하위항목이고, 수거대상이다. 알아서 매핑 등록된다
		@Repository
			- 컴포넌트 중에서도 데이터 저장소에 접근하는 컴포넌트들을 등록하기 위해 사용하는 어노테이션
			- 기능 차이는 없고 구분용
		@Service
			- 컴포넌트들 중에서도 비즈니스 로직을 수행하는 컴포넌트들을 등록하기 위해 사용하는 어노테이션
			- 기능 차이는 없고 구분용
		
# 스프링 컨텍스트에 등록되어 있는 의존성을 주입하는 방법들
	1. @Autowired
	
	2. 생성자를 사용하는 방법
		(1) 해당 의존성 객체를 private final로 설정한다
		(2) 해당 의존성 객체를 반드시 초기화 해야만 하게끔 만들어 둔다
		(3) 스프링에 의해 해당 의존성이 자동으로 채워진다 
		
	3. 메서드를 사용하는 방법
		(1) 의존성 주입을 원하는 필드의 Setter 메서드 위에 @Autowired를 작성
		(2) 스프링에 의해 자동으로 의존성 부여
		
# 컴포넌트가 스캔되는 범위
	- 메인 클래스 위에 @SrpingBootApplication에 기본적으로 컴포넌트 스캔이 설정되어 있다
	- 기본 설정에 따르면 base package 내부에 있는 모든 컴포넌트를 스캔하도록 설정되어 있다
	- base package 바깥에 만드는 클래스들은 스캔의 대상이 되지 않는다
	- 따로 설정을 추가하면 등록가능 하지만 굳이 그러지는 않는다
